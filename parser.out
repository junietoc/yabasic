Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    B
    END
    ID

Grammar

Rule 0     S' -> c
Rule 1     c -> s
Rule 2     value -> VAR
Rule 3     value -> INT
Rule 4     term -> OP value
Rule 5     term -> term term
Rule 6     term -> empty
Rule 7     expr -> value
Rule 8     expr -> value term
Rule 9     s -> NUMBER LET VAR ASSIGN expr
Rule 10    s -> NUMBER GOTO INT
Rule 11    s -> NUMBER PRINT STRING
Rule 12    empty -> <empty>
Rule 13    varprint -> VAR SEP VAR
Rule 14    varprint -> varprint SEP VAR
Rule 15    s -> NUMBER PRINT VAR
Rule 16    s -> NUMBER PRINT varprint

Terminals, with rules where they appear

ASSIGN               : 9
B                    : 
END                  : 
GOTO                 : 10
ID                   : 
INT                  : 3 10
LET                  : 9
NUMBER               : 9 10 11 15 16
OP                   : 4
PRINT                : 11 15 16
SEP                  : 13 14
STRING               : 11
VAR                  : 2 9 13 13 14 15
error                : 

Nonterminals, with rules where they appear

c                    : 0
empty                : 6
expr                 : 9
s                    : 1
term                 : 5 5 8
value                : 4 7 8
varprint             : 14 16

Parsing method: LALR

state 0

    (0) S' -> . c
    (1) c -> . s
    (9) s -> . NUMBER LET VAR ASSIGN expr
    (10) s -> . NUMBER GOTO INT
    (11) s -> . NUMBER PRINT STRING
    (15) s -> . NUMBER PRINT VAR
    (16) s -> . NUMBER PRINT varprint

    NUMBER          shift and go to state 3

    c                              shift and go to state 1
    s                              shift and go to state 2

state 1

    (0) S' -> c .



state 2

    (1) c -> s .

    $end            reduce using rule 1 (c -> s .)


state 3

    (9) s -> NUMBER . LET VAR ASSIGN expr
    (10) s -> NUMBER . GOTO INT
    (11) s -> NUMBER . PRINT STRING
    (15) s -> NUMBER . PRINT VAR
    (16) s -> NUMBER . PRINT varprint

    LET             shift and go to state 4
    GOTO            shift and go to state 5
    PRINT           shift and go to state 6


state 4

    (9) s -> NUMBER LET . VAR ASSIGN expr

    VAR             shift and go to state 7


state 5

    (10) s -> NUMBER GOTO . INT

    INT             shift and go to state 8


state 6

    (11) s -> NUMBER PRINT . STRING
    (15) s -> NUMBER PRINT . VAR
    (16) s -> NUMBER PRINT . varprint
    (13) varprint -> . VAR SEP VAR
    (14) varprint -> . varprint SEP VAR

    STRING          shift and go to state 9
    VAR             shift and go to state 10

    varprint                       shift and go to state 11

state 7

    (9) s -> NUMBER LET VAR . ASSIGN expr

    ASSIGN          shift and go to state 12


state 8

    (10) s -> NUMBER GOTO INT .

    $end            reduce using rule 10 (s -> NUMBER GOTO INT .)


state 9

    (11) s -> NUMBER PRINT STRING .

    $end            reduce using rule 11 (s -> NUMBER PRINT STRING .)


state 10

    (15) s -> NUMBER PRINT VAR .
    (13) varprint -> VAR . SEP VAR

    $end            reduce using rule 15 (s -> NUMBER PRINT VAR .)
    SEP             shift and go to state 13


state 11

    (16) s -> NUMBER PRINT varprint .
    (14) varprint -> varprint . SEP VAR

    $end            reduce using rule 16 (s -> NUMBER PRINT varprint .)
    SEP             shift and go to state 14


state 12

    (9) s -> NUMBER LET VAR ASSIGN . expr
    (7) expr -> . value
    (8) expr -> . value term
    (2) value -> . VAR
    (3) value -> . INT

    VAR             shift and go to state 15
    INT             shift and go to state 18

    expr                           shift and go to state 16
    value                          shift and go to state 17

state 13

    (13) varprint -> VAR SEP . VAR

    VAR             shift and go to state 19


state 14

    (14) varprint -> varprint SEP . VAR

    VAR             shift and go to state 20


state 15

    (2) value -> VAR .

    OP              reduce using rule 2 (value -> VAR .)
    $end            reduce using rule 2 (value -> VAR .)


state 16

    (9) s -> NUMBER LET VAR ASSIGN expr .

    $end            reduce using rule 9 (s -> NUMBER LET VAR ASSIGN expr .)


state 17

    (7) expr -> value .
    (8) expr -> value . term
    (4) term -> . OP value
    (5) term -> . term term
    (6) term -> . empty
    (12) empty -> .

  ! shift/reduce conflict for OP resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 7 (expr -> value .)
    $end            reduce using rule 7 (expr -> value .)
    OP              shift and go to state 22

  ! OP              [ reduce using rule 12 (empty -> .) ]
  ! $end            [ reduce using rule 12 (empty -> .) ]

    term                           shift and go to state 21
    empty                          shift and go to state 23

state 18

    (3) value -> INT .

    OP              reduce using rule 3 (value -> INT .)
    $end            reduce using rule 3 (value -> INT .)


state 19

    (13) varprint -> VAR SEP VAR .

    SEP             reduce using rule 13 (varprint -> VAR SEP VAR .)
    $end            reduce using rule 13 (varprint -> VAR SEP VAR .)


state 20

    (14) varprint -> varprint SEP VAR .

    SEP             reduce using rule 14 (varprint -> varprint SEP VAR .)
    $end            reduce using rule 14 (varprint -> varprint SEP VAR .)


state 21

    (8) expr -> value term .
    (5) term -> term . term
    (4) term -> . OP value
    (5) term -> . term term
    (6) term -> . empty
    (12) empty -> .

  ! shift/reduce conflict for OP resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 8 (expr -> value term .)
    $end            reduce using rule 8 (expr -> value term .)
    OP              shift and go to state 22

  ! OP              [ reduce using rule 12 (empty -> .) ]
  ! $end            [ reduce using rule 12 (empty -> .) ]

    term                           shift and go to state 24
    empty                          shift and go to state 23

state 22

    (4) term -> OP . value
    (2) value -> . VAR
    (3) value -> . INT

    VAR             shift and go to state 15
    INT             shift and go to state 18

    value                          shift and go to state 25

state 23

    (6) term -> empty .

    OP              reduce using rule 6 (term -> empty .)
    $end            reduce using rule 6 (term -> empty .)


state 24

    (5) term -> term term .
    (5) term -> term . term
    (4) term -> . OP value
    (5) term -> . term term
    (6) term -> . empty
    (12) empty -> .

  ! shift/reduce conflict for OP resolved as shift
  ! shift/reduce conflict for OP resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 5 (term -> term term .)
    $end            reduce using rule 5 (term -> term term .)
    OP              shift and go to state 22

  ! OP              [ reduce using rule 5 (term -> term term .) ]
  ! OP              [ reduce using rule 12 (empty -> .) ]
  ! $end            [ reduce using rule 12 (empty -> .) ]

    term                           shift and go to state 24
    empty                          shift and go to state 23

state 25

    (4) term -> OP value .

    OP              reduce using rule 4 (term -> OP value .)
    $end            reduce using rule 4 (term -> OP value .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for OP in state 17 resolved as shift
WARNING: shift/reduce conflict for OP in state 21 resolved as shift
WARNING: shift/reduce conflict for OP in state 24 resolved as shift
WARNING: shift/reduce conflict for OP in state 24 resolved as shift
WARNING: reduce/reduce conflict in state 17 resolved using rule (expr -> value)
WARNING: rejected rule (empty -> <empty>) in state 17
WARNING: reduce/reduce conflict in state 21 resolved using rule (expr -> value term)
WARNING: rejected rule (empty -> <empty>) in state 21
WARNING: reduce/reduce conflict in state 24 resolved using rule (term -> term term)
WARNING: rejected rule (empty -> <empty>) in state 24
WARNING: Rule (empty -> <empty>) is never reduced
